<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Наводнения</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ode.js@1.0.0/ode.min.js"></script>
    <style>
        .chart-wrapper {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .chart-wrapper.full-width {
            width: 100%;
        }

        .chart-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .chart-subtitle {
            color: #666;
            margin-bottom: 10px;
        }
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f9ff;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #1a4b8c;
            margin-bottom: 10px;
            border-bottom: 2px solid #1a4b8c;
            padding-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #555;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .section {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #1a4b8c;
        }
        
        h2 {
            color: #1a4b8c;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #e8f1ff;
            color: #1a4b8c;
            font-weight: 600;
        }
        
        tr:hover {
            background-color: #f9f9f9;
        }
        
        input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input:focus {
            border-color: #1a4b8c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(26, 75, 140, 0.2);
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            background-color: #1a4b8c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #0d3a73;
        }
        
        button.secondary {
            background-color: #4a6fa5;
        }
        
        button.secondary:hover {
            background-color: #3a5a8c;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-wrapper {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .chart-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
            color: #1a4b8c;
        }
        
        .info-text {
            background-color: #e8f4ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #1a4b8c;
        }
        
        .function-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .function-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-family: monospace;
        }
        
        .function-item:last-child {
            border-bottom: none;
        }
        
        .highlight {
            background-color: #fff9e6;
            padding: 3px 5px;
            border-radius: 3px;
            font-weight: 600;
        }
        .chart-subtitle {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        @media (max-width: 1200px) {
            .charts-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .button-container {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Моделирование показателей наводнения</h1>
        <div class="subtitle">Ввод показателей и визуализация динамики показателей X<sub>1</sub>-X<sub>12</sub></div>
                
        <!-- Таблица 1: Вводимые значения Xn и максимальные значения -->
        <div class="section">
            <h2>Таблица 1: Начальные условия и максимальные значения показателей X<sub>n</sub></h2>
            <p>Введите начальные условия показателей X<sub>n</sub> и их максимальные показатели.</p>
            <table id="table1">
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>Описание</th>
                        <th>Начальное значение X<sub>n</sub></th>
                        <th>Максимальное значение</th>
                    </tr>
                </thead>
                <tbody id="table1-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Таблица 2: Константные значения -->
        <div class="section">
            <h2>Таблица 2</h2>
            <p>Введите начальные характеристики</p>
            <table id="table2">
                <thead>
                    <tr>
                        <th>Параметр</th>
                        <th>Значение</th>
                    </tr>
                </thead>
                <tbody id="table2-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Таблица 3: Функции -->
        <div class="section">
            <h2>Таблица 3: Коэффициенты функций f(x) = a*x³ + b*x² + c*x + d</h2>
            <p>Введите коэффициенты для 150 функций, используемых в модели.</p>
            <table id="table3">
                <thead>
                    <tr>
                        <th>Функция</th>
                        <th>Коэффициент a</th>
                        <th>Коэффициент b</th>
                        <th>Коэффициент c</th>
                        <th>Коэффициент d</th>
                    </tr>
                </thead>
                <tbody id="table3-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        
        </div>
        
        

        <!-- Кнопки управления -->
        <div class="button-container">
            <button id="calculate-btn">Рассчитать динамику показателей</button>
            <button id="reset-btn" class="secondary">Сбросить значения по умолчанию</button>
            <button id="random-btn" class="secondary">Заполнить случайными значениями</button>
        </div>
        
        <!-- Графики -->
        <div class="section">
            <h2>Динамика характеристик X<sub>n</sub> в 5 временных точках</h2>
            <p>Лепестковые графики показывают значения характеристик X<sub>1</sub>-X<sub>14</sub> в 5 моментов времени (t=0, t=0.2, t=0.4, t=0.6, t=0.8, t=1)</p>
            <div class="charts-container" id="charts-container">
                <!-- Графики будут сгенерированы JavaScript -->
            </div>
        </div>

        <canvas id="myChart" width="600" height="300"></canvas>

        <!-- Описание уравнений -->
        <div class="section">
            <h2>Уравнения изменений характеристик X<sub>n</sub></h2>
            <p>Общий вид уравнений, характеризующих изменение характеристик во времени:</p>
            <ul>
                <li><span class="highlight">X₁(t)</span> - Численность группировки сил, участвующих в аварийно-спасательных работах</li>
                <li><span class="highlight">X₂(t)</span> - Количество жилых домов, разрушенных и поврежденных в результате наводнения</li>
                <li><span class="highlight">X₃(t)</span> - Численность населения, эвакуированного из зоны затопления</li>
                <li><span class="highlight">X₄(t)</span> - Количество погибших</li>
                <li><span class="highlight">X₅(t)</span> - Протяженность железных и автомобильных дорог, оказавшихся в зоне затопления</li>
                <li><span class="highlight">X₆(t)</span> - Количество промышленных предприятий в зоне наводнения</li>
                <li><span class="highlight">X₇(t)</span> - Количество транспортных средств, участвующих в аварийно-спасательных работах</li>
                <li><span class="highlight">X₈(t)</span> - Численность населения в зоне затопления</li>
                <li><span class="highlight">X₉(t)</span> - Площадь сельскохозяйственных угодий, охваченных наводнением</li>
                <li><span class="highlight">X₁₀(t)</span> - Количество погибших сельскохозяйственных животных</li>
                <li><span class="highlight">X₁₁(t)</span> - Ущерб основным производственным фондам в зоне затопления</li>
                <li><span class="highlight">X₁₂(t)</span> - Ущерб оборотным производственным фондам в зоне затопления</li>
            </ul>
            <p>Каждое уравнение включает нормировочный множитель, вспомогательные функции и учитывает влияние управляющих переменных p(t) и возмущений ζ(t).</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Описания характеристик Xn
            const xnDescriptions = [
                "Численность группировки сил, участвующих в аварийно-спасательных работах",
                "Количество жилых домов, разрушенных и поврежденных в результате наводнения",
                "Численность населения, эвакуированного из зоны затопления",
                "Количество погибших",
                "Протяженность железных и автомобильных дорог, оказавшихся в зоне затопления",
                "Количество промышленных предприятий в зоне наводнения",
                "Количество транспортных средств, участвующих в аварийно-спасательных работах",
                "Численность населения в зоне затопления",
                "Площадь сельскохозяйственных угодий, охваченных наводнением",
                "Количество погибших сельскохозяйственных животных",
                "Ущерб основным производственным фондам в зоне затопления",
                "Ущерб оборотным производственным фондам в зоне затопления"
            ];
            
            // Описания констант
            const constants = [
                {name: "S"},
                {name: "F"},
                {name: "G"},
                {name: "T"},
                {name: "A"},
                {name: "D"},
                {name: "I"},
                {name: "P"},
                {name: "C"}
            ];
            
            // Инициализация данных
            let table1Data = [];
            let table2Data = [];
            let table3DataFS = [];
            let table3DataFX = [];
            let table4Data = [];
            
            // Инициализация данных по умолчанию
            function initDefaultData() {
                // Таблица 1: Начальные и максимальные значения Xn
                table1Data = [];
                for (let i = 1; i < 13; i++) {
                    table1Data.push({
                        id: i,
                        initial: i <= 14 ? (0.5 + Math.random() * 0.3).toFixed(2) : "0.00",
                        max: 1
                    });
                }
                // Таблица 2: Значения возмущения
                table2Data = [];
                constants.forEach((constant, index) => {
                    table2Data.push({
                        name: constant.name,
                        value: (Math.random() * 0.6).toFixed(2)
                    });
                });
                
                // Таблица 3: Коэффициенты функций
                table3DataFS = [];
                for (let i = 1; i <= 12; i++) {
                    table3DataFS.push({
                        id: i,
                        a: (Math.random() * 0.8).toFixed(3),
                        b: (Math.random() * 0.8).toFixed(3),
                        c: (Math.random() * 0.8).toFixed(3),
                        d: (Math.random()).toFixed(3)
                    });
                }
                table3DataFX = [];
                for (let i = 1; i <= 21; i++) {
                    table3DataFX.push({
                        id: i,
                        a: (Math.random() * 0.8).toFixed(3),
                        b: (Math.random() * 0.8).toFixed(3),
                        c: (Math.random() * 0.8).toFixed(3),
                        d: (Math.random()).toFixed(3)
                    });
                }

                // Таблица 4:
                table4Data = [];
                for (let i = 0; i < 14; i++) {
                    table4Data.push({
                        id: i,
                        name: "X" + (i+1),
                        max: 1,
                        min: (Math.random() * 0.2).toFixed(4)
                    });
                }
                
                
                renderTables();
            }
            
            // Заполнение случайными значениями
            function fillRandomData() {
                // Таблица 1
                table1Data.forEach(item => {
                    item.initial = (0.5 + Math.random() * 0.3).toFixed(2);
                    item.max = (0.7 + Math.random() * 0.3).toFixed(2);
                });
                console.log(table1Data)
                // Таблица 2
                table2Data.forEach(item => {
                    item.value = (Math.random() * 0.3).toFixed(2);
                });
                
                // Таблица 3
                table3DataFS.forEach(item => {
                    item.a = (Math.random() * 0.8).toFixed(3);
                    item.b = (Math.random() * 0.8).toFixed(3);
                    item.c = (Math.random() * 0.8).toFixed(3);
                    item.d = (Math.random() * 0.8).toFixed(3);
                });
                table3DataFX.forEach(item => {
                    item.a = (Math.random() * 0.8).toFixed(3);
                    item.b = (Math.random() * 0.8).toFixed(3);
                    item.c = (Math.random() * 0.8).toFixed(3);
                    item.d = (Math.random() * 0.8).toFixed(3);
                });
                // Таблица 4
                for (let i = 0; i < 14; i++) {
                    table4Data.push({
                        id: i,
                        name: "X" + (i),
                        max: 1,
                        min: (Math.random() * 0.2).toFixed(4)
                    });
                }
                
                renderTables();
            }
            
            // Рендер таблиц
            function renderTables() {
                // Таблица 1
                const table1Body = document.getElementById('table1-body');
                table1Body.innerHTML = '';
                
                table1Data.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    const descIndex = Math.min(index, xnDescriptions.length - 1);
                    
                    row.innerHTML = `
                        <td>X<sub>${item.id}</sub></td>
                        <td>${xnDescriptions[descIndex]}</td>
                        <td><input type="number" step="0.01" min="0" max="1" class="xn-input" data-index="${index}" data-type="initial" value="${item.initial}"></td>
                        <td><input type="number" step="0.01" min="0" max="1" class="xn-input" data-index="${index}" data-type="max" value="${item.max}"></td>
                    `;
                    
                    table1Body.appendChild(row);
                });
                
                // Таблица 2
                const table2Body = document.getElementById('table2-body');
                table2Body.innerHTML = '';
                
                table2Data.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${item.name}</td>
                        <td><input type="number" step="0.01" min="0" max="1" class="const-input" data-index="${index}" value="${item.value}"></td>
                    `;
                    
                    table2Body.appendChild(row);
                });
                
                // Таблица 3
                const table3Body = document.getElementById('table3-body');
                table3Body.innerHTML = '';
                
                // Показываем все вспомогательные функции в таблице
                for (let i = 0; i < 12; i++) {
                    if (i===2 || i===3 || i === 6 || i === 11) continue;
                    const item = table3DataFS[i];
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>f<sub>${item.id}</sub>(S(t)) = </td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.a}">
                            <div>·S(t)³ +</div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.b}">
                            <div>·S(t)² +</div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.c}">
                            <div>·S(t) +</div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.d}">
                            <div></div>
                        </div></td>
                    `;
                    
                    table3Body.appendChild(row);
                }
                let fig = ["₁","₂","₃","₄","₅","₆","₇","₈","₉","₁₀","₁₁","₁₂","₁₃","₁₄"];

                let v = ["1x₈","2x₈","2x₁","2x₇","3x₈","3x₁","3x₇",
                    "4x₈", "4x₇", "4x₁", "5x₁", "5x₇", "6x₈", "7x₁",
                    "8x₄", "9x₁", "9x₇", "10x₁", "10x₇", "11x₆", "12x₁₁"
                ]

                for (let i = 0; i < 21; i++) {
                    console.log(table3DataFX[i])
                    const item = table3DataFX[i];
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>f<sub>${v[i]}</sub> = </td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.a}">
                            <div>·${v[i].length <= 3?v[i].slice(1):v[i].slice(2)}³ + </div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.b}">
                            <div>·${v[i].length <= 3?v[i].slice(1):v[i].slice(2)}² + </div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.c}">
                            <div>·${v[i].length <= 3?v[i].slice(1):v[i].slice(2)} + </div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 110px" 
                                data-index="${i}" data-coeff="a" value="${item.d}">
                            <div></div>
                        </div></td>
                    `;
                    
                    table3Body.appendChild(row);
                }

                
                
                // Добавляем обработчики событий для инпутов
                addEventListeners();
            }
            
            // Добавление обработчиков событий
            function addEventListeners() {
                // Обработчики для таблицы 1
                document.querySelectorAll('.xn-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        const type = this.dataset.type;
                        table1Data[index][type] = this.value;
                    });
                });
                
                // Обработчики для таблицы 2
                document.querySelectorAll('.const-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table2Data[index].value = this.value;
                    });
                });
                
                // Обработчики для таблицы 3
                document.querySelectorAll('.func-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        const coeff = this.dataset.coeff;
                        table3DataFS[index][coeff] = this.value;
                    });
                });

                // Обработчики для таблицы 4
                document.querySelectorAll('.max-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table4Data[index].max = this.value;
                    });
                });
                document.querySelectorAll('.min-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table4Data[index].min = this.value;
                    });
                });
            }

            function FSValue(n,x){
                // Проверка входных данных
                if (x === undefined || x === null || isNaN(x)) {
                    console.warn(`Invalid x value for F: ${x}`);
                    return 1; // нейтральное значение
                }
                
                // логика вычисления f(index, x)
                let result = parseFloat(table3DataFS[n].a * x * x * x + table3DataFS[n].b * x * x + table3DataFS[n].c * x + table3DataFS[n].d)
                
                // Защита от проблем
                if (isNaN(result) || !isFinite(result)) {
                    console.warn(`NaN/Infinity in F${index}(${x}), returning 1`);
                    return 1;
                }
                
                // Ограничение диапазона
                // if (result < 1e-10) result = 1e-10;
                // if (result > 1e10) result = 1e10;
                
                return result;
            }
            function FXValue(n,x){
                // Проверка входных данных
                if (x === undefined || x === null || isNaN(x)) {
                    console.warn(`Invalid x value for F: ${x}`);
                    return 1; // нейтральное значение
                }
                
                // логика вычисления f(index, x)
                let result = parseFloat(table3DataFX[n].a * x * x * x + table3DataFX[n].b * x * x + table3DataFX[n].c * x + table3DataFX[n].d)
                
                // Защита от проблем
                if (isNaN(result) || !isFinite(result)) {
                    console.warn(`NaN/Infinity in F${index}(${x}), returning 1`);
                    return 1;
                }
                
                // Ограничение диапазона
                // if (result < 1e-10) result = 1e-10;
                // if (result > 1e10) result = 1e10;
                
                return result;
            }
            

            // Расчет значений Xn в временных точках
            function calculateXnValues() {
                const maxValues = [];
                for (let i = 0; i < 12; i++) {
                    maxValues.push(parseFloat(table1Data[i].max));
                }
                        
                const xnCount = 12; // X1-X14
                const initialValuesX = table1Data.slice(0, xnCount).map(item => parseFloat(item.initial));
                
                // Дифференциальные функции изменения X1-X14
                function cllculateX1(t, X1, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FSValue(0,S(t)) * FXValue(0,othersArray[7])

                    maxValues[0] = Math.max(othersArray[0] + calcVal/ parseFloat(maxValues[0]), maxValues[0])

                    calcVal *= (1 /  parseFloat(maxValues[0]))

                    return calcVal;
                }
                function cllculateX2(t, X2, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= F(t) * G(t) * FSValue(1,S(t)) * FXValue(1,othersArray[7])

                    calcVal -= FXValue(2,othersArray[0]) * FXValue(3,othersArray[8])

                    maxValues[1] = Math.max(othersArray[1] + calcVal/ parseFloat(maxValues[1]), maxValues[1])

                    calcVal *= (0.1 /  parseFloat(maxValues[1]))

                    return calcVal;
                }
                function cllculateX3(t, X3, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FXValue(4,othersArray[9]) * FXValue(5,othersArray[0]) * FXValue(6,othersArray[8])

                    maxValues[2] = Math.max(othersArray[2] + calcVal/ parseFloat(maxValues[2]), maxValues[2])

                    calcVal *= (1 /  parseFloat(maxValues[2]))

                    return calcVal;
                }
                function cllculateX4(t, X4, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= F(t) * G(t) * T(t) * FXValue(7,othersArray[9]) * FXValue(8,othersArray[8]) * FXValue(9,othersArray[0])

                    maxValues[3] = Math.max(othersArray[3] + calcVal/ parseFloat(maxValues[3]), maxValues[3])

                    calcVal *= (1/ parseFloat(maxValues[3]))

                    return calcVal;
                }
                function cllculateX5(t, X5, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= A(t) * FSValue(4,S(t))

                    calcVal -= FXValue(10,othersArray[0]) * FXValue(11,othersArray[8])

                    maxValues[4] = Math.max(othersArray[4] + calcVal/ parseFloat(maxValues[4]), maxValues[4])

                    calcVal *= (1 / parseFloat(maxValues[4]))

                    return calcVal;
                }
                function cllculateX6(t, X6, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FSValue(5,S(t)) * FXValue(12,othersArray[9])
                    
                    maxValues[5] = Math.max(othersArray[5] + calcVal/ parseFloat(maxValues[5]), maxValues[5])

                    calcVal *= (1 / parseFloat(maxValues[5]))

                    return calcVal;
                }
                function cllculateX7(t, X7, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FXValue(13,othersArray[0])

                    maxValues[6] = Math.max(othersArray[6] + calcVal/ parseFloat(maxValues[6]), maxValues[6])
                    
                    calcVal *= (1 / parseFloat(maxValues[6]))

                    return calcVal;
                }
                function cllculateX8(t, X8, othersArray){
                    var calcVal = 1;

                    calcVal *= D(t) * FSValue(7,S(t))
                    calcVal -= FXValue(14,othersArray[3])
                    
                    maxValues[7] = Math.max(othersArray[7] + calcVal/ parseFloat(maxValues[7]), maxValues[7])

                    calcVal *= (10 / parseFloat(maxValues[7]))

                    return calcVal;
                }
                function cllculateX9(t, X9, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= I(t) * FSValue(8,S(t)) 
                    calcVal -= FXValue(15,othersArray[0]) * FXValue(16,othersArray[6])
                    
                    maxValues[8] = Math.max(othersArray[8] + calcVal/ parseFloat(maxValues[8]), maxValues[8])

                    calcVal *= (1 / parseFloat(maxValues[8]))

                    return calcVal;
                }
                function cllculateX10(t, X10, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= F(t) * G(t) * T(t) * FSValue(9,S(t)) * FXValue(17,othersArray[0]) * FXValue(18,othersArray[8])

                    maxValues[9] = Math.max(othersArray[9] + calcVal/ parseFloat(maxValues[9]), maxValues[9])

                    calcVal *= (1 / parseFloat(maxValues[9]))

                    return calcVal;
                }
                function cllculateX11(t, X11, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= P(t) * C(t) * F(t) * G(t) * D(t) * FSValue(10,S(t)) * FXValue(19,othersArray[5])

                    maxValues[10] = Math.max(othersArray[10] + calcVal/ parseFloat(maxValues[10]), maxValues[10])

                    calcVal *= (1 / parseFloat(maxValues[10]))

                    return calcVal;
                }
                function cllculateX12(t, X12, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FXValue(20,othersArray[10])

                    maxValues[11] = Math.max(othersArray[11] + calcVal/ parseFloat(maxValues[11]), maxValues[11])
                    
                    calcVal *= (0.1/ parseFloat(maxValues[11]))

                    return calcVal;
                }
                

                function f_dopri(t, y){
                    return [ cllculateX1(t, y[0], initialValuesX), cllculateX2(t, y[1], initialValuesX), cllculateX3(t, y[2], initialValuesX), cllculateX4(t, y[3], initialValuesX),
                cllculateX5(t, y[4], initialValuesX), cllculateX6(t, y[5], initialValuesX), cllculateX7(t, y[6], initialValuesX), cllculateX8(t, y[7], initialValuesX),
                cllculateX9(t, y[8], initialValuesX), cllculateX10(t, y[9], initialValuesX), cllculateX11(t, y[10], initialValuesX), cllculateX12(t, y[11], initialValuesX)
                ];
                }
                const tol = 1e-12;

                const { solveODE } = math;

                const tspan1 = [0, 1];

                const sol1 = solveODE(f_dopri, tspan1, initialValuesX, { method: 'RK45', tol: 1e-6, maxStep: 0.2});
                console.log(sol1);
                
                const timePoints = 6;

                const xnOverTime = Array.from({length: timePoints}, () => []);

                let count = 0;

                for (let u = 0;u<sol1.t.length;u++){
                    if ( sol1.t[u] === 0 ||
                    sol1.t[u]> 0.19 && sol1.t[u]<0.200001 ||
                    sol1.t[u]> 0.39 && sol1.t[u]<0.41 ||
                    sol1.t[u]> 0.59 && sol1.t[u]<0.61 ||
                    sol1.t[u]>= 0.8
                    )
                    {
                        let val = sol1.y[count]
                        for (let r=0;r<val.length;r++){
                            val[r] = Math.max(val[r], parseFloat(table4Data[r].min))
                            val[r] = Math.min(val[r], parseFloat(table4Data[r].max))
                        }
                        xnOverTime[count] = val;
                        count++;
                        if (count === 5) break
                    }
                }
                for (let u = 0;u<sol1.t.length;u++){
                    if ( sol1.t[u] === 1)
                    {
                        let val = sol1.y[count]
                        for (let r=0;r<val.length;r++){
                            val[r] = Math.max(val[r], parseFloat(table4Data[r].min))
                            val[r] = Math.min(val[r], parseFloat(table4Data[r].max))
                        }
                        xnOverTime[5] = val
                        break
                    }
                }

                let maxs = []

                for (let i=0;i<6;i++){
                    let max = 0
                    for (let p=0;p<14;p++){
                        
                        max = Math.max(parseFloat(xnOverTime[i][p]), max)
                    }
                    maxs[i] = max
                }
                for (let o=0;o<6;o++){
                    for (let d=0;d<14;d++){
                        if (maxs[o] > 1) xnOverTime[o][d] = parseFloat(xnOverTime[o][d]) / maxs[o]
                    }
                }
                
                return xnOverTime;
            }

            /////////////////
           
            let chart;
            
            // Создание лепестковых и линейного графиков
            function createCharts(xnOverTime) {
                if (chart) {
                    chart.destroy(); // Уничтожаем предыдущий график
                }

                let selectedTimes = ['t=0 (начало)', 't=0.2', 't=0.4', 't=0.6', 't=0.8', 't=1']
                const ctx = document.getElementById('myChart').getContext('2d');
                
                // Количество переменных (длина внутреннего массива)
                const varCount = xnOverTime[0].length;

                // названия временных точек
                const labels = selectedTimes;

                // набор цветов (если переменных много — цвета циклически повторяются)
                const colors = [
                    'red', 'blue', 'green', 'orange', 'purple',
                    'brown', 'pink', 'cyan', 'magenta', 'olive',
                    "LightGreen","Aqua","Khaki","SteelBlue"
                ];

                // Формируем наборы данных для Chart.js
                let datasets = [];

                for (let v = 0; v < varCount; v++) {

                    // Берём все значения x_v(t_i) для переменной v
                    const dataV = xnOverTime.map(row => row[v]);

                    datasets.push({
                        label: `X${v+1}(t)`,
                        data: dataV,
                        fill: false,
                        borderColor: colors[v % colors.length],
                        borderWidth: 2,
                        tension: 0.2
                    });
                }

                // Строим график
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'right',
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Время t'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Значение переменных'
                                }
                            }
                        }
                    }
                });


                const chartsContainer = document.getElementById('charts-container');
                chartsContainer.innerHTML = '';
                
                const timeLabels = ['t=0 (начало)', 't=0.2', 't=0.4', 't=0.6', 't=0.8', 't=1'];
                const xnLabels = Array.from({length: 12}, (_, i) => `X${i+1}`);
                
                // Цвета для графиков
                const chartColors = [
                    'rgba(26, 75, 140, 0.7)',
                    'rgba(65, 105, 225, 0.7)',
                    'rgba(70, 130, 180, 0.7)',
                    'rgba(100, 149, 237, 0.7)',
                    'rgba(30, 144, 255, 0.7)',
                    'rgba(90, 144, 255, 0.7)'
                ];
                
                // Создаем 5 графиков для каждого момента времени
                for (let t = 0; t < 6; t++) {
                    const chartWrapper = document.createElement('div');
                    chartWrapper.className = 'chart-wrapper';
                    
                    const chartTitle = document.createElement('div');
                    chartTitle.className = 'chart-title';
                    chartTitle.textContent = timeLabels[t];
                    
                    // Добавляем информацию о максимальных значениях
                    const maxInfo = document.createElement('div');
                    maxInfo.className = 'chart-subtitle';
                    maxInfo.innerHTML = '<small>Макс. значения: X₁=' + table1Data[0].max + 
                                        ', X₈=' + table1Data[7].max + 
                                        ', X₁2=' + table1Data[11].max + '</small>';
                    
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart-${t}`;
                    
                    chartWrapper.appendChild(chartTitle);
                    chartWrapper.appendChild(maxInfo);
                    chartWrapper.appendChild(canvas);
                    chartsContainer.appendChild(chartWrapper);
                    
                    // Получаем максимальные значения для каждой характеристики
                    const maxValues = [];
                    for (let i = 0; i < 12; i++) {
                        maxValues.push(parseFloat(table1Data[i].max));
                    }
                    
                    // Находим максимальное из максимальных значений для масштаба графика
                    const overallMax = Math.max(...maxValues);
                    
                  

                    // Создаем график
                    const ctx = canvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'radar',
                        data: {
                            labels: xnLabels,
                            datasets: [
                                {
                                    label: `Текущие значения X₁-X₁₄`,
                                    data: xnOverTime[t],
                                    backgroundColor: chartColors[t],
                                    borderColor: chartColors[t],//.replace('0.7', '1'),
                                    borderWidth: 2,
                                    pointBackgroundColor: chartColors[t],//.replace('0.7', '1'),
                                    pointRadius: 4
                                },
                                {
                                    label: 'Максимальные значения',
                                    data: maxValues,
                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 1,
                                    borderDash: [5, 5],
                                    pointBackgroundColor: 'rgba(255, 99, 132, 0.8)',
                                    pointRadius: 2,
                                    fill: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            scales: {
                                r: {
                                    beginAtZero: true,
                                    max: overallMax,
                                    ticks: {
                                        stepSize: overallMax / 5,
                                        callback: function(value) {
                                            return value.toFixed(2);
                                        }
                                    },
                                    pointLabels: {
                                        font: {
                                            size: 11
                                        },
                                        // callback: function(label, index) {
                                        //     // Добавляем максимальное значение к названию характеристики
                                        //     return label + ' (max: ' + maxValues[index].toFixed(2) + ')';
                                        // }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const datasetLabel = context.dataset.label;
                                            const index = context.dataIndex;
                                            const value = context.raw;
                                            const maxVal = maxValues[index];
                                            const percent = ((value / maxVal) * 100).toFixed(1);
                                            
                                            if (context.datasetIndex === 0) {
                                                return `${datasetLabel}: ${value.toFixed(3)} (${percent}% от макс.)`;
                                            } else {
                                                return `${datasetLabel}: ${value.toFixed(3)}`;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
            
            ////
            ////
            // Обработчики кнопок
            document.getElementById('calculate-btn').addEventListener('click', function() {
                const xnOverTime = calculateXnValues();
                createCharts(xnOverTime);
            });
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                initDefaultData();
            });
            
            document.getElementById('random-btn').addEventListener('click', function() {
                fillRandomData();
            });
            
            // Инициализация при загрузке
            initDefaultData();
            
            
            for (let i=0; i<table2Data.length;i++){
                console.log(table2Data[i].value);
            }

            function S(t){
                current_sources = parseFloat(table2Data[0].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function F(t){
                current_sources = parseFloat(table2Data[1].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function G(t){
                current_sources = parseFloat(table2Data[2].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function T(t){
                current_sources = parseFloat(table2Data[3].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function A(t){
                current_sources = parseFloat(table2Data[4].value) + 0.01 * t * 100
                z1 = current_sources
                return Math.min(Math.max(z1, 0), 1)
            }
            function D(t){
                current_sources = 1 * t * t * t + 0.4 * t * t + 0.7 * t + 0.3 
                z1 = current_sources
                return Math.min(Math.max(z1, 0), 1)
            }
            function I(t){
                current_sources = parseFloat(table2Data[6].value) + 0.01 * t * 100
                z1 = current_sources
                return Math.min(Math.max(z1, 0), 1)
            }
            function P(t){
                return parseFloat(table2Data[7].value)
            }
            function C(t){
                return parseFloat(table2Data[8].value)
            }

            // Автоматический расчет при загрузке
            setTimeout(() => {
                const xnOverTime = calculateXnValues();
                createCharts(xnOverTime);
            }, 500);
        });
    </script>
</body>
</html>