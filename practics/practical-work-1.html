<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моделирование характеристик хранилищ данных</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ode.js@1.0.0/ode.min.js"></script>
    <style>
        .chart-wrapper {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .chart-wrapper.full-width {
            width: 100%;
        }

        .chart-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .chart-subtitle {
            color: #666;
            margin-bottom: 10px;
        }
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f9ff;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #1a4b8c;
            margin-bottom: 10px;
            border-bottom: 2px solid #1a4b8c;
            padding-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #555;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .section {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #1a4b8c;
        }
        
        h2 {
            color: #1a4b8c;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #e8f1ff;
            color: #1a4b8c;
            font-weight: 600;
        }
        
        tr:hover {
            background-color: #f9f9f9;
        }
        
        input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input:focus {
            border-color: #1a4b8c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(26, 75, 140, 0.2);
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            background-color: #1a4b8c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #0d3a73;
        }
        
        button.secondary {
            background-color: #4a6fa5;
        }
        
        button.secondary:hover {
            background-color: #3a5a8c;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-wrapper {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .chart-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
            color: #1a4b8c;
        }
        
        .info-text {
            background-color: #e8f4ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #1a4b8c;
        }
        
        .function-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .function-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-family: monospace;
        }
        
        .function-item:last-child {
            border-bottom: none;
        }
        
        .highlight {
            background-color: #fff9e6;
            padding: 3px 5px;
            border-radius: 3px;
            font-weight: 600;
        }
        .chart-subtitle {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        @media (max-width: 1200px) {
            .charts-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .button-container {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Моделирование показателей хранилищ данных</h1>
        <div class="subtitle">Ввод показателей и визуализация динамики показателей X<sub>1</sub>-X<sub>14</sub></div>
                
        <!-- Таблица 1: Вводимые значения Xn и максимальные значения -->
        <div class="section">
            <h2>Таблица 1: Начальные условия и максимальные значения показателей X<sub>n</sub></h2>
            <p>Введите начальные условия показателей X<sub>n</sub> и их максимальные показатели.</p>
            <table id="table1">
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>Описание</th>
                        <th>Начальное значение X<sub>n</sub></th>
                        <th>Максимальное значение</th>
                    </tr>
                </thead>
                <tbody id="table1-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Таблица 2: Константные значения -->
        <div class="section">
            <h2>Таблица 2: Значения возмущений параметров модели</h2>
            <p>Введите значения возмущений, используемых в уравнениях модели.</p>
            <table id="table2">
                <thead>
                    <tr>
                        <th>Параметр</th>
                        <th>Описание</th>
                        <th>Значение</th>
                    </tr>
                </thead>
                <tbody id="table2-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Таблица 3: Функции -->
        <div class="section">
            <h2>Таблица 3: Коэффициенты функций f(x) = a*x³ + b*x² + c*x + d</h2>
            <p>Введите коэффициенты для 150 функций, используемых в модели. Отображаются первые 5 функций, полный список доступен ниже.</p>
            <table id="table3">
                <thead>
                    <tr>
                        <th>Функция</th>
                        <th>Коэффициент a</th>
                        <th>Коэффициент b</th>
                        <th>Коэффициент c</th>
                        <th>Коэффициент d</th>
                    </tr>
                </thead>
                <tbody id="table3-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        
        </div>
        
        <div class="section">
            <table id="table4">
                <thead>
                    <tr>
                        <th>Параметр</th>
                        <th>Максимальное ограничение</th>
                        <th>Минимальное ограничение</th>
                    </tr>
                </thead>
                <tbody id="table4-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- Кнопки управления -->
        <div class="button-container">
            <button id="calculate-btn">Рассчитать динамику показателей</button>
            <button id="reset-btn" class="secondary">Сбросить значения по умолчанию</button>
            <button id="random-btn" class="secondary">Заполнить случайными значениями</button>
        </div>
        
        <!-- Графики -->
        <div class="section">
            <h2>Динамика характеристик X<sub>n</sub> в 5 временных точках</h2>
            <p>Лепестковые графики показывают значения характеристик X<sub>1</sub>-X<sub>14</sub> в 5 моментов времени (t=0, t=1, t=2, t=3, t=4)</p>
            <div class="charts-container" id="charts-container">
                <!-- Графики будут сгенерированы JavaScript -->
            </div>
        </div>

        <canvas id="myChart" width="600" height="300"></canvas>

        <!-- Описание уравнений -->
        <div class="section">
            <h2>Уравнения изменений характеристик X<sub>n</sub></h2>
            <p>Общий вид уравнений, характеризующих изменение характеристик во времени:</p>
            <ul>
                <li><span class="highlight">X₁(t)</span> - эффективность функционирования хранилища данных</li>
                <li><span class="highlight">X₂(t)</span> - качество программного обеспечения</li>
                <li><span class="highlight">X₃(t)</span> - корректность программного обеспечения</li>
                <li><span class="highlight">X₄(t)</span> - надежность программного обеспечения</li>
                <li><span class="highlight">X₅(t)</span> - доступность программного обеспечения</li>
                <li><span class="highlight">X₆(t)</span> - возможность интенсивного использования ПО</li>
                <li><span class="highlight">X₇(t)</span> - прослеживаемость ПО</li>
                <li><span class="highlight">X₈(t)</span> - функциональная полнота ПО</li>
                <li><span class="highlight">X₉(t)</span> - обеспечение требуемой последовательности работ при проектировании</li>
                <li><span class="highlight">X₁₀(t)</span> - практичность ПО</li>
                <li><span class="highlight">X₁₁(t)</span> - устойчивость к ошибкам данных ПО</li>
                <li><span class="highlight">X₁₂(t)</span> - эффективность выполнения транзакций</li>
                <li><span class="highlight">X₁₃(t)</span> - степень мотивации персонала</li>
                <li><span class="highlight">X₁₄(t)</span> - удобство тестирования ПО</li>
            </ul>
            <p>Каждое уравнение включает нормировочный множитель, вспомогательные функции и учитывает влияние управляющих переменных p(t) и возмущений ζ(t).</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Описания характеристик Xn
            const xnDescriptions = [
                "Эффективность функционирования хранилища данных",
                "Качество программного обеспечения (ПО)",
                "Корректность ПО",
                "Надежность программного обеспечения",
                "Доступность программного обеспечения",
                "Возможность интенсивного использования ПО",
                "Прослеживаемость ПО",
                "Функциональная полнота ПО",
                "Обеспечение требуемой последовательности работ при проектировании хранилища",
                "Практичность ПО",
                "Устойчивость к ошибкам данных программного обеспечения",
                "Эффективность выполнения транзакций",
                "Степень мотивации персонала, осуществляющего эксплуатацию хранилища данных",
                "Удобство тестирования ПО"
            ];
            
            // Описания констант
            const constants = [
                {name: "ζ₁", description: "увеличение количества источников новых данных, предназначенных для интеграции с данными хранилища"},
                {name: "ζ₂", description: "частота изменения периодов сдачи финансовой отчетности предприятия"},
                {name: "ζ₃", description: "сокращение квалифицированной поддержки вендора, вызванное ужесточением режима санкций"},
                {name: "ζ₄", description: "рост интенсивности перехода на Open Source решения при развитии хранилища данных"},
                {name: "ζ₅", description: "увеличение количества новых стандартов при реализации Open Source решений"}
            ];
            
            // Инициализация данных
            let table1Data = [];
            let table2Data = [];
            let table3Data = [];
            let table4Data = [];
            
            // Инициализация данных по умолчанию
            function initDefaultData() {
                // Таблица 1: Начальные и максимальные значения Xn
                table1Data = [];
                for (let i = 1; i < 15; i++) {
                    table1Data.push({
                        id: i,
                        initial: i <= 14 ? (0.5 + Math.random() * 0.3).toFixed(2) : "0.00",
                        max: (0.8 + Math.random() * 0.2).toFixed(2)
                    });
                }
                // Таблица 2: Значения возмущения
                table2Data = [];
                constants.forEach((constant, index) => {
                    table2Data.push({
                        name: constant.name,
                        value: (Math.random() * 0.3).toFixed(2)
                    });
                });
                
                // Таблица 3: Коэффициенты функций
                table3Data = [];
                for (let i = 1; i <= 150; i++) {
                    table3Data.push({
                        id: i,
                        a: (Math.random() * 10 - 0.1).toFixed(3),
                        b: (Math.random() * 10).toFixed(3),
                        c: (Math.random() * 10).toFixed(3),
                        d: (Math.random()).toFixed(3)
                    });
                }
                // Таблица 4:
                table4Data = [];
                for (let i = 0; i < 14; i++) {
                    table4Data.push({
                        id: i,
                        name: "X" + (i+1),
                        max: Math.min((0.8 + Math.random() * 0.2).toFixed(4), parseFloat(table1Data[i].max)),
                        min: (Math.random() * 0.2).toFixed(4)
                    });
                }
                
                
                renderTables();
            }
            
            // Заполнение случайными значениями
            function fillRandomData() {
                // Таблица 1
                table1Data.forEach(item => {
                    item.initial = (0.5 + Math.random() * 0.3).toFixed(2);
                    item.max = (0.7 + Math.random() * 0.3).toFixed(2);
                });
                console.log(table1Data)
                // Таблица 2
                table2Data.forEach(item => {
                    item.value = (Math.random() * 0.3).toFixed(2);
                });
                
                // Таблица 3
                table3Data.forEach(item => {
                    item.a = (Math.random() * 10 - 0.1).toFixed(3);
                    item.b = (Math.random() * 10).toFixed(3);
                    item.c = (Math.random() * 10).toFixed(3);
                    item.d = (Math.random() * 10).toFixed(3);
                });
                // Таблица 4
                for (let i = 0; i < 14; i++) {
                    table4Data.push({
                        id: i,
                        name: "X" + (i),
                        max: Math.min((0.8 + Math.random() * 0.2).toFixed(4), parseFloat(table1Data[i].max)),
                        min: (Math.random() * 0.2).toFixed(4)
                    });
                }
                
                renderTables();
            }
            
            // Рендер таблиц
            function renderTables() {
                // Таблица 1
                const table1Body = document.getElementById('table1-body');
                table1Body.innerHTML = '';
                
                table1Data.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    const descIndex = Math.min(index, xnDescriptions.length - 1);
                    
                    row.innerHTML = `
                        <td>X<sub>${item.id}</sub></td>
                        <td>${xnDescriptions[descIndex]}</td>
                        <td><input type="number" step="0.01" min="0" max="1" class="xn-input" data-index="${index}" data-type="initial" value="${item.initial}"></td>
                        <td><input type="number" step="0.01" min="0" max="1" class="xn-input" data-index="${index}" data-type="max" value="${item.max}"></td>
                    `;
                    
                    table1Body.appendChild(row);
                });
                
                // Таблица 2
                const table2Body = document.getElementById('table2-body');
                table2Body.innerHTML = '';
                
                table2Data.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${item.name}</td>
                        <td>${constants[index].description}</td>
                        <td><input type="number" step="0.01" min="0" max="1" class="const-input" data-index="${index}" value="${item.value}"></td>
                    `;
                    
                    table2Body.appendChild(row);
                });
                
                // Таблица 3
                const table3Body = document.getElementById('table3-body');
                table3Body.innerHTML = '';
                let fig = ["₁","₂","₃","₄","₅","₆","₇","₈","₉","₁₀","₁₁","₁₂","₁₃","₁₄"];
                // Показываем все вспомогательные функции в таблице
                for (let i = 0; i < 150; i++) {
                    const item = table3Data[i];
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>f<sub>${item.id}</sub>(x${fig[i%14]}) = </td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 150px" 
                                data-index="${i}" data-coeff="a" value="${item.a}">
                            <div>·x${fig[i%14]}³ + </div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 150px" 
                                data-index="${i}" data-coeff="a" value="${item.b}">
                            <div>·x${fig[i%14]}² + </div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 150px" 
                                data-index="${i}" data-coeff="a" value="${item.c}">
                            <div>·x${fig[i%14]} + </div>
                        </div></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="func-input" style="width: 150px" 
                                data-index="${i}" data-coeff="a" value="${item.d}">
                            <div></div>
                        </div></td>
                    `;
                    
                    table3Body.appendChild(row);
                }

                // Таблица 4
                const table4Body = document.getElementById('table4-body');
                table4Body.innerHTML = '';
                
                for (let i=0;i<14;i++){
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${table4Data[i].name}</td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="max-input" style="width: 150px" 
                        data-index="${i}" data-coeff="a" value="${table4Data[i].max}"></td>
                        <td><div style="display: flex; align-items: center; gap: 4px;">
                            <input type="number" step="0.001" min="0" max="10" class="min-input" style="width: 150px" 
                        data-index="${i}" data-coeff="a" value="${table4Data[i].min}"></td>
                    `;
                    
                    table4Body.appendChild(row);
                };
                
                // Добавляем обработчики событий для инпутов
                addEventListeners();
            }
            
            // Добавление обработчиков событий
            function addEventListeners() {
                // Обработчики для таблицы 1
                document.querySelectorAll('.xn-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        const type = this.dataset.type;
                        table1Data[index][type] = this.value;
                    });
                });
                
                // Обработчики для таблицы 2
                document.querySelectorAll('.const-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table2Data[index].value = this.value;
                    });
                });
                
                // Обработчики для таблицы 3
                document.querySelectorAll('.func-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        const coeff = this.dataset.coeff;
                        table3Data[index][coeff] = this.value;
                    });
                });

                // Обработчики для таблицы 4
                document.querySelectorAll('.max-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table4Data[index].max = this.value;
                    });
                });
                document.querySelectorAll('.min-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table4Data[index].min = this.value;
                    });
                });
            }

            function FValue(n,x){
                // Проверка входных данных
                if (x === undefined || x === null || isNaN(x)) {
                    console.warn(`Invalid x value for F: ${x}`);
                    return 1; // нейтральное значение
                }
                
                // логика вычисления f(index, x)
                let result = parseFloat(table3Data[n].a * x * x * x + table3Data[n].b * x * x + table3Data[n].c * x + table3Data[n].d)
                
                // Защита от проблем
                if (isNaN(result) || !isFinite(result)) {
                    console.warn(`NaN/Infinity in F${index}(${x}), returning 1`);
                    return 1;
                }
                
                // Ограничение диапазона
                // if (result < 1e-10) result = 1e-10;
                // if (result > 1e10) result = 1e10;
                
                return result;
            }

            

            // Расчет значений Xn в временных точках
            function calculateXnValues() {
                const maxValues = [];
                for (let i = 0; i < 14; i++) {
                    maxValues.push(parseFloat(table1Data[i].max));
                }
                        
                const xnCount = 14; // X1-X14
                const initialValuesX = table1Data.slice(0, xnCount).map(item => parseFloat(item.initial));
                
                // Дифференциальные функции изменения X1-X14
                function cllculateX1(t, X1, othersArray){
                    var calcVal = 1;
                    for (let j = 0; j < xnCount; j++){
                        //if (j===0) continue;
                        const Xi = othersArray[j];

                        calcVal *= FValue(j,Xi);
                    }

                    calcVal *= (zeta1(t) + zeta2(t) + zeta3(t) - zeta4(t) - zeta5(t))

                    maxValues[0] = Math.max(othersArray[0] + calcVal/ parseFloat(maxValues[0]), maxValues[0])

                    calcVal *= (0.1 / parseFloat(maxValues[0]))

                    return calcVal;
                }
                function cllculateX2(t, X2, othersArray){
                    var calcVal = 1;
                    for (let j = 0; j < xnCount; j++){
                        //if (j===1) continue;
                        const Xi = othersArray[j];

                        calcVal *= FValue(14+j,Xi);
                    }

                    calcVal *= (zeta1(t) + zeta2(t) + zeta3(t) - zeta4(t) - zeta5(t))

                    maxValues[1] = Math.max(othersArray[1] + calcVal/ parseFloat(maxValues[1]), maxValues[1])

                    calcVal *= (0.1 /  parseFloat(maxValues[1]))

                    return calcVal;
                }
                function cllculateX3(t, X3, othersArray){
                    var calcVal = 1;
                    for (let j = 0; j < xnCount; j++){
                        //if (j===2) continue;
                        const Xi = othersArray[j];
                        calcVal *= FValue(28 + j,Xi);
                    }

                    calcVal *= (zeta1(t) + zeta2(t) + zeta3(t) + zeta4(t) - zeta5(t))

                    maxValues[2] = Math.max(othersArray[2] + calcVal/ parseFloat(maxValues[2]), maxValues[2])

                    calcVal *= (0.1 /  parseFloat(maxValues[2]))

                    return calcVal;
                }
                function cllculateX4(t, X4, othersArray){
                    var calcVal = 1;
                    for (let j = 0; j < xnCount; j++){
                        if (j===4 || j===5 )continue
                        const Xi = othersArray[j];

                        calcVal *= FValue(42 + j,Xi);
                    }

                    calcVal *= zeta5(t)  
                    calcVal -= (zeta1(t) + zeta2(t) + zeta3(t) + zeta4(t) + FValue(46, othersArray[4])) * FValue(47, othersArray[5])

                    maxValues[3] = Math.max(othersArray[3] + calcVal/ parseFloat(maxValues[3]), maxValues[3])

                    calcVal *= (0.1 / parseFloat(maxValues[3]))

                    return calcVal;
                }
                function cllculateX5(t, X5, othersArray){
                    var calcVal = 1;
                    
                    calcVal = (FValue(56,othersArray[3]) * FValue(57,othersArray[5]) * FValue(58,othersArray[8]) * FValue(59,othersArray[10]) * FValue(60,othersArray[12]))
                    calcVal *= ((zeta1(t) + zeta2(t) + zeta4(t) + zeta5(t)) - zeta5(t))
                    
                    maxValues[4] = Math.max(othersArray[4] + calcVal/ parseFloat(maxValues[4]), maxValues[4])

                    calcVal *= (0.1 / parseFloat(maxValues[4]))

                    return calcVal;
                }
                function cllculateX6(t, X6, othersArray){
                    var calcVal = 1;
                    
                    for (let j = 0; j < xnCount; j++){
                        //if (j===5) continue;
                        const Xi = othersArray[j];

                        calcVal *= FValue(61 + j,Xi);
                    }

                    calcVal *=  (zeta1(t) + zeta2(t) - zeta5(t)) 
                    
                    maxValues[5] = Math.max(othersArray[5] + calcVal/ parseFloat(maxValues[5]), maxValues[5])

                    calcVal *= (0.1 / parseFloat(maxValues[5]))

                    return calcVal;
                }
                function cllculateX7(t, X7, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= (FValue(75,othersArray[1]) * FValue(76,othersArray[3]) * FValue(77,othersArray[13])) 
                    calcVal -= zeta5(t)

                    maxValues[6] = Math.max(othersArray[6] + calcVal/ parseFloat(maxValues[6]), maxValues[6])
                    
                    calcVal *= (0.1 / parseFloat(maxValues[6]))

                    return calcVal;
                }
                function cllculateX8(t, X8, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= (FValue(75,othersArray[0]) * FValue(76,othersArray[1]) * FValue(77,othersArray[2]) * FValue(78,othersArray[3]) * FValue(79,othersArray[5]) * FValue(80,othersArray[8]) * FValue(81,othersArray[9]))
                    calcVal *=  (zeta1(t) + zeta2(t) + zeta3(t))
                    calcVal -= (zeta1(t) + zeta2(t))
                    
                    maxValues[7] = Math.max(othersArray[7] + calcVal/ parseFloat(maxValues[7]), maxValues[7])

                    calcVal *= (0.1 / parseFloat(maxValues[7]))

                    return calcVal;
                }
                function cllculateX9(t, X9, othersArray){
                    var calcVal = 1;
                    
                    for (let j = 0; j < 7; j++){
                        const Xi = othersArray[j];

                        calcVal *= FValue(82 + j,Xi);
                    }
                    calcVal *= (FValue(89,othersArray[9]) * FValue(90,othersArray[10]) * FValue(91,othersArray[11]) * FValue(92,othersArray[12]) * FValue(93,othersArray[13]) )   
                    calcVal *= (zeta4(t) + zeta5(t))
                    calcVal -= (zeta1(t) + zeta2(t) + zeta3(t))
                    
                    maxValues[8] = Math.max(othersArray[8] + calcVal/ parseFloat(maxValues[8]), maxValues[8])

                    calcVal *= (0.1 / parseFloat(maxValues[8]))

                    return calcVal;
                }
                function cllculateX10(t, X10, othersArray){
                    var calcVal = 1;
                    
                    for (let j = 0; j < 12; j++){
                        // if (j===9) continue;
                        // if (j===12 || j===13 )continue
                        
                        const Xi = othersArray[j]

                        calcVal *= FValue(94 + j,Xi);
                    }

                    calcVal *=  (zeta1(t) + zeta2(t))
                    calcVal -= (zeta3(t) * FValue(106,othersArray[12])* FValue(107,othersArray[13])) 
                    
                    maxValues[9] = Math.max(othersArray[9] + calcVal/ parseFloat(maxValues[9]), maxValues[9])

                    calcVal *= (0.1 / parseFloat(maxValues[9]))

                    return calcVal;
                }
                function cllculateX11(t, X11, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FValue(108,othersArray[0]) * FValue(109,othersArray[1]) * FValue(110,othersArray[2]) * FValue(111,othersArray[4]) * FValue(112,othersArray[7]) * FValue(113,othersArray[9]) * FValue(114,othersArray[11]) * FValue(115,othersArray[12]) * FValue(116,othersArray[13])

                    calcVal -= (FValue(117,othersArray[4])* FValue(118,othersArray[5]) * (zeta1(t) + zeta2(t) + zeta3(t) + zeta4(t) + zeta5(t)) )

                    maxValues[10] = Math.max(othersArray[10] + calcVal/ parseFloat(maxValues[10]), maxValues[10])

                    calcVal *= (0.1 / parseFloat(maxValues[10]))

                    return calcVal;
                }
                function cllculateX12(t, X12, othersArray){
                    var calcVal = 1;
                    
                    for (let j = 0; j < 14; j++){
                        const Xi = othersArray[j]
                        calcVal *= FValue(119 + j,Xi);
                    }

                    calcVal *= (zeta1(t) + zeta4(t) + zeta5(t))
                    calcVal -= zeta3(t)

                    maxValues[11] = Math.max(othersArray[11] + calcVal/ parseFloat(maxValues[11]), maxValues[11])
                    
                    calcVal *= (0.1 / parseFloat(maxValues[11]))

                    return calcVal;
                }
                function cllculateX13(t, X13, othersArray){
                    var calcVal = 1;
                    
                    for (let j = 0; j < 8; j++){
                        let Xi = othersArray[j]
                        calcVal *= FValue(132 + j,Xi);
                    }

                    calcVal *= FValue(140,othersArray[9]) * FValue(141,othersArray[10]) * FValue(142,othersArray[11]) * FValue(143,othersArray[12]) * FValue(144,othersArray[13])
                    calcVal -= FValue(145,othersArray[8]) * (zeta1(t) + zeta2(t) + zeta3(t) + zeta4(t) + zeta5(t)) 
                    
                    maxValues[12] = Math.max(othersArray[12] + calcVal/ parseFloat(maxValues[12]), maxValues[12])

                    calcVal *= (0.1 / parseFloat(maxValues[12]))

                    return calcVal;
                }
                function cllculateX14(t, X14, othersArray){
                    var calcVal = 1;
                    
                    calcVal *= FValue(146 ,othersArray[4]) * FValue(147 ,othersArray[6]) * FValue(148,othersArray[10]) * FValue(149 ,othersArray[12])

                    calcVal -= (zeta1(t) + zeta2(t) + zeta3(t) + zeta4(t) + zeta5(t))
                    
                    maxValues[13] = Math.max(othersArray[13] + calcVal/ parseFloat(maxValues[13]), maxValues[13])

                    calcVal *= (0.1 / parseFloat(maxValues[13]))

                    return calcVal;
                }

                function f_dopri(t, y){
                    return [ cllculateX1(t, y[0], initialValuesX), cllculateX2(t, y[1], initialValuesX), cllculateX3(t, y[2], initialValuesX), cllculateX4(t, y[3], initialValuesX),
                cllculateX5(t, y[4], initialValuesX), cllculateX6(t, y[5], initialValuesX), cllculateX7(t, y[6], initialValuesX), cllculateX8(t, y[7], initialValuesX),
                cllculateX9(t, y[8], initialValuesX), cllculateX10(t, y[9], initialValuesX), cllculateX11(t, y[10], initialValuesX), cllculateX12(t, y[11], initialValuesX),
                cllculateX13(t, y[12], initialValuesX), cllculateX14(t, y[13], initialValuesX)
                ];
                }
                const tol = 1e-12;

                const { solveODE } = math;

                const tspan1 = [0, 1];

                const sol1 = solveODE(f_dopri, tspan1, initialValuesX, { method: 'RK45', tol: 1e-6, maxStep: 0.2});
                console.log(sol1);
                
                const timePoints = 6;

                const xnOverTime = Array.from({length: timePoints}, () => []);

                let count = 0;

                for (let u = 0;u<sol1.t.length;u++){
                    if ( sol1.t[u] === 0 ||
                    sol1.t[u]> 0.19 && sol1.t[u]<0.200001 ||
                    sol1.t[u]> 0.39 && sol1.t[u]<0.41 ||
                    sol1.t[u]> 0.59 && sol1.t[u]<0.61 ||
                    sol1.t[u]>= 0.8
                    )
                    {
                        let val = sol1.y[count]
                        for (let r=0;r<val.length;r++){
                            val[r] = Math.max(val[r], parseFloat(table4Data[r].min))
                            val[r] = Math.min(val[r], parseFloat(table4Data[r].max))
                        }
                        xnOverTime[count] = val;
                        count++;
                        if (count === 5) break
                    }
                }
                for (let u = 0;u<sol1.t.length;u++){
                    if ( sol1.t[u] === 1)
                    {
                        let val = sol1.y[count]
                        for (let r=0;r<val.length;r++){
                            val[r] = Math.max(val[r], parseFloat(table4Data[r].min))
                            val[r] = Math.min(val[r], parseFloat(table4Data[r].max))
                        }
                        xnOverTime[5] = val
                        break
                    }
                }

                let maxs = []

                for (let i=0;i<6;i++){
                    let max = 0
                    for (let p=0;p<14;p++){
                        
                        max = Math.max(parseFloat(xnOverTime[i][p]), max)
                    }
                    maxs[i] = max
                }
                for (let o=0;o<6;o++){
                    for (let d=0;d<14;d++){
                        if (maxs[o] > 1) xnOverTime[o][d] = parseFloat(xnOverTime[o][d]) / maxs[o]
                    }
                }
                
                return xnOverTime;
            }

            /////////////////
           
            let chart;
            
            // Создание лепестковых и линейного графиков
            function createCharts(xnOverTime) {
                if (chart) {
                    chart.destroy(); // Уничтожаем предыдущий график
                }

                let selectedTimes = ['t=0 (начало)', 't=0.2', 't=0.4', 't=0.6', 't=0.8', 't=1']
                const ctx = document.getElementById('myChart').getContext('2d');
                
                // Количество переменных (длина внутреннего массива)
                const varCount = xnOverTime[0].length;

                // названия временных точек
                const labels = selectedTimes;

                // набор цветов (если переменных много — цвета циклически повторяются)
                const colors = [
                    'red', 'blue', 'green', 'orange', 'purple',
                    'brown', 'pink', 'cyan', 'magenta', 'olive',
                    "LightGreen","Aqua","Khaki","SteelBlue"
                ];

                // Формируем наборы данных для Chart.js
                let datasets = [];

                for (let v = 0; v < varCount; v++) {

                    // Берём все значения x_v(t_i) для переменной v
                    const dataV = xnOverTime.map(row => row[v]);

                    datasets.push({
                        label: `X${v+1}(t)`,
                        data: dataV,
                        fill: false,
                        borderColor: colors[v % colors.length],
                        borderWidth: 2,
                        tension: 0.2
                    });
                }

                // Строим график
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'right',
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Время t'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Значение переменных'
                                }
                            }
                        }
                    }
                });


                const chartsContainer = document.getElementById('charts-container');
                chartsContainer.innerHTML = '';
                
                const timeLabels = ['t=0 (начало)', 't=0.2', 't=0.4', 't=0.6', 't=0.8', 't=1'];
                const xnLabels = Array.from({length: 14}, (_, i) => `X${i+1}`);
                
                // Цвета для графиков
                const chartColors = [
                    'rgba(26, 75, 140, 0.7)',
                    'rgba(65, 105, 225, 0.7)',
                    'rgba(70, 130, 180, 0.7)',
                    'rgba(100, 149, 237, 0.7)',
                    'rgba(30, 144, 255, 0.7)',
                    'rgba(90, 144, 255, 0.7)'
                ];
                
                // Создаем 5 графиков для каждого момента времени
                for (let t = 0; t < 6; t++) {
                    const chartWrapper = document.createElement('div');
                    chartWrapper.className = 'chart-wrapper';
                    
                    const chartTitle = document.createElement('div');
                    chartTitle.className = 'chart-title';
                    chartTitle.textContent = timeLabels[t];
                    
                    // Добавляем информацию о максимальных значениях
                    const maxInfo = document.createElement('div');
                    maxInfo.className = 'chart-subtitle';
                    maxInfo.innerHTML = '<small>Макс. значения: X₁=' + table1Data[0].max + 
                                        ', X₈=' + table1Data[7].max + 
                                        ', X₁₄=' + table1Data[13].max + '</small>';
                    
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart-${t}`;
                    
                    chartWrapper.appendChild(chartTitle);
                    chartWrapper.appendChild(maxInfo);
                    chartWrapper.appendChild(canvas);
                    chartsContainer.appendChild(chartWrapper);
                    
                    // Получаем максимальные значения для каждой характеристики
                    const maxValues = [];
                    for (let i = 0; i < 14; i++) {
                        maxValues.push(parseFloat(table1Data[i].max));
                    }

                    const maxC = []
                    for (let i = 0; i < 14; i++) {
                        maxC.push(parseFloat(table4Data[i].max));
                    }
                    
                    // Находим максимальное из максимальных значений для масштаба графика
                    const overallMax = Math.max(...maxValues);
                    
                  

                    // Создаем график
                    const ctx = canvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'radar',
                        data: {
                            labels: xnLabels,
                            datasets: [
                                {
                                    label: `Текущие значения X₁-X₁₄`,
                                    data: xnOverTime[t],
                                    backgroundColor: chartColors[t],
                                    borderColor: chartColors[t],//.replace('0.7', '1'),
                                    borderWidth: 2,
                                    pointBackgroundColor: chartColors[t],//.replace('0.7', '1'),
                                    pointRadius: 4
                                },
                                {
                                    label: 'Максимальные значения',
                                    data: maxValues,
                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 1,
                                    borderDash: [5, 5],
                                    pointBackgroundColor: 'rgba(255, 99, 132, 0.8)',
                                    pointRadius: 2,
                                    fill: false
                                },
                                {
                                    label: 'Максимальные ограничения',
                                    data: maxC,
                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                    borderColor: 'rgba(100, 99, 132, 0.8)',
                                    borderWidth: 1,
                                    borderDash: [5, 5],
                                    pointBackgroundColor: 'rgba(100, 99, 132, 0.8)',
                                    pointRadius: 2,
                                    fill: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            scales: {
                                r: {
                                    beginAtZero: true,
                                    max: overallMax,
                                    ticks: {
                                        stepSize: overallMax / 5,
                                        callback: function(value) {
                                            return value.toFixed(2);
                                        }
                                    },
                                    pointLabels: {
                                        font: {
                                            size: 11
                                        },
                                        callback: function(label, index) {
                                            // Добавляем максимальное значение к названию характеристики
                                            return label + ' (max: ' + maxValues[index].toFixed(2) + ')';
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const datasetLabel = context.dataset.label;
                                            const index = context.dataIndex;
                                            const value = context.raw;
                                            const maxVal = maxValues[index];
                                            const percent = ((value / maxVal) * 100).toFixed(1);
                                            
                                            if (context.datasetIndex === 0) {
                                                return `${datasetLabel}: ${value.toFixed(3)} (${percent}% от макс.)`;
                                            } else {
                                                return `${datasetLabel}: ${value.toFixed(3)}`;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
            
            ////
            ////
            // Обработчики кнопок
            document.getElementById('calculate-btn').addEventListener('click', function() {
                const xnOverTime = calculateXnValues();
                createCharts(xnOverTime);
            });
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                initDefaultData();
            });
            
            document.getElementById('random-btn').addEventListener('click', function() {
                fillRandomData();
            });
            
            // Инициализация при загрузке
            initDefaultData();
            
            
            for (let i=0; i<table2Data.length;i++){
                console.log(table2Data[i].value);
            }

            function zeta1(t){
                current_sources = parseFloat(table2Data[0].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function zeta2(t){
                current_sources = parseFloat(table2Data[1].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function zeta3(t){
                current_sources = parseFloat(table2Data[2].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function zeta4(t){
                current_sources = parseFloat(table2Data[3].value) + 0.01 * t * 100
                z1 = current_sources 
                return Math.min(Math.max(z1, 0), 1)
            }
            function zeta5(t){
                current_sources = parseFloat(table2Data[4].value) + 0.01 * t * 100
                z1 = current_sources
                return Math.min(Math.max(z1, 0), 1)
            }

            // Автоматический расчет при загрузке
            setTimeout(() => {
                const xnOverTime = calculateXnValues();
                createCharts(xnOverTime);
            }, 500);
        });
    </script>
</body>
</html>