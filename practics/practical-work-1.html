<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моделирование характеристик хранилищ данных</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: #f5f9ff;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #1a4b8c;
            margin-bottom: 10px;
            border-bottom: 2px solid #1a4b8c;
            padding-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #555;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .section {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #1a4b8c;
        }
        
        h2 {
            color: #1a4b8c;
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #e8f1ff;
            color: #1a4b8c;
            font-weight: 600;
        }
        
        tr:hover {
            background-color: #f9f9f9;
        }
        
        input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        
        input:focus {
            border-color: #1a4b8c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(26, 75, 140, 0.2);
        }
        
        .button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            background-color: #1a4b8c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #0d3a73;
        }
        
        button.secondary {
            background-color: #4a6fa5;
        }
        
        button.secondary:hover {
            background-color: #3a5a8c;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-wrapper {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .chart-title {
            text-align: center;
            font-weight: 600;
            margin-bottom: 10px;
            color: #1a4b8c;
        }
        
        .info-text {
            background-color: #e8f4ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #1a4b8c;
        }
        
        .function-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .function-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-family: monospace;
        }
        
        .function-item:last-child {
            border-bottom: none;
        }
        
        .highlight {
            background-color: #fff9e6;
            padding: 3px 5px;
            border-radius: 3px;
            font-weight: 600;
        }
        .chart-subtitle {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        @media (max-width: 1200px) {
            .charts-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .button-container {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Моделирование характеристик хранилищ данных</h1>
        <div class="subtitle">Ввод параметров и визуализация динамики показателей X<sub>1</sub>-X<sub>14</sub></div>
                
        <!-- Таблица 1: Вводимые значения Xn и максимальные значения -->
        <div class="section">
            <h2>Таблица 1: Начальные и максимальные значения характеристик X<sub>n</sub></h2>
            <p>Введите начальные значения характеристик X<sub>n</sub> и их максимальные значения. X<sub>15</sub> добавлен для возможных расширений модели.</p>
            <table id="table1">
                <thead>
                    <tr>
                        <th>Характеристика</th>
                        <th>Описание</th>
                        <th>Начальное значение X<sub>n</sub></th>
                        <th>Максимальное значение</th>
                    </tr>
                </thead>
                <tbody id="table1-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Таблица 2: Константные значения -->
        <div class="section">
            <h2>Таблица 2: Константные значения параметров модели</h2>
            <p>Введите значения констант, используемых в уравнениях модели.</p>
            <table id="table2">
                <thead>
                    <tr>
                        <th>Параметр</th>
                        <th>Описание</th>
                        <th>Значение</th>
                    </tr>
                </thead>
                <tbody id="table2-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Таблица 3: Функции -->
        <div class="section">
            <h2>Таблица 3: Коэффициенты функций f(x) = a*x² + b*x + c</h2>
            <p>Введите коэффициенты для 150 функций, используемых в модели. Отображаются первые 5 функций, полный список доступен ниже.</p>
            <table id="table3">
                <thead>
                    <tr>
                        <th>Функция</th>
                        <th>Коэффициент a</th>
                        <th>Коэффициент b</th>
                        <th>Коэффициент c</th>
                    </tr>
                </thead>
                <tbody id="table3-body">
                    <!-- Данные будут сгенерированы JavaScript -->
                </tbody>
            </table>
            
            <div class="function-list" id="function-list">
                <!-- Полный список функций будет сгенерирован JavaScript -->
            </div>
        </div>
        
        <!-- Кнопки управления -->
        <div class="button-container">
            <button id="calculate-btn">Рассчитать динамику показателей</button>
            <button id="reset-btn" class="secondary">Сбросить значения по умолчанию</button>
            <button id="random-btn" class="secondary">Заполнить случайными значениями</button>
        </div>
        
        <!-- Графики -->
        <div class="section">
            <h2>Динамика характеристик X<sub>n</sub> в 5 временных точках</h2>
            <p>Лепестковые графики показывают значения характеристик X<sub>1</sub>-X<sub>14</sub> в 5 моментов времени (t=0, t=1, t=2, t=3, t=4)</p>
            <div class="charts-container" id="charts-container">
                <!-- Графики будут сгенерированы JavaScript -->
            </div>
        </div>
        
        <!-- Описание уравнений -->
        <div class="section">
            <h2>Уравнения изменений характеристик X<sub>n</sub></h2>
            <p>Общий вид уравнений, характеризующих изменение характеристик во времени:</p>
            <ul>
                <li><span class="highlight">X₁(t)</span> - эффективность функционирования хранилища данных</li>
                <li><span class="highlight">X₂(t)</span> - качество программного обеспечения</li>
                <li><span class="highlight">X₃(t)</span> - корректность программного обеспечения</li>
                <li><span class="highlight">X₄(t)</span> - надежность программного обеспечения</li>
                <li><span class="highlight">X₅(t)</span> - доступность программного обеспечения</li>
                <li><span class="highlight">X₆(t)</span> - возможность интенсивного использования ПО</li>
                <li><span class="highlight">X₇(t)</span> - прослеживаемость ПО</li>
                <li><span class="highlight">X₈(t)</span> - функциональная полнота ПО</li>
                <li><span class="highlight">X₉(t)</span> - обеспечение требуемой последовательности работ при проектировании</li>
                <li><span class="highlight">X₁₀(t)</span> - практичность ПО</li>
                <li><span class="highlight">X₁₁(t)</span> - устойчивость к ошибкам данных ПО</li>
                <li><span class="highlight">X₁₂(t)</span> - эффективность выполнения транзакций</li>
                <li><span class="highlight">X₁₃(t)</span> - степень мотивации персонала</li>
                <li><span class="highlight">X₁₄(t)</span> - удобство тестирования ПО</li>
            </ul>
            <p>Каждое уравнение включает нормировочный множитель, вспомогательные функции и учитывает влияние управляющих переменных p(t) и возмущений ζ(t).</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Описания характеристик Xn
            const xnDescriptions = [
                "Эффективность функционирования хранилища данных",
                "Качество программного обеспечения (ПО)",
                "Корректность ПО",
                "Надежность программного обеспечения",
                "Доступность программного обеспечения",
                "Возможность интенсивного использования ПО",
                "Прослеживаемость ПО",
                "Функциональная полнота ПО",
                "Обеспечение требуемой последовательности работ при проектировании хранилища",
                "Практичность ПО",
                "Устойчивость к ошибкам данных программного обеспечения",
                "Эффективность выполнения транзакций",
                "Степень мотивации персонала, осуществляющего эксплуатацию хранилища данных",
                "Удобство тестирования ПО"
            ];
            
            // Описания констант
            const constants = [
                {name: "ζ₁", description: "увеличение количества источников новых данных, предназначенных для интеграции с данными хранилища"},
                {name: "ζ₂", description: "частота изменения периодов сдачи финансовой отчетности предприятия"},
                {name: "ζ₃", description: "сокращение квалифицированной поддержки вендора, вызванное ужесточением режима санкций"},
                {name: "ζ₄", description: "рост интенсивности перехода на Open Source решения при развитии хранилища данных"},
                {name: "ζ₅", description: "увеличение количества новых стандартов при реализации Open Source решений"}
            ];
            
            // Инициализация данных
            let table1Data = [];
            let table2Data = [];
            let table3Data = [];
            
            // Инициализация данных по умолчанию
            function initDefaultData() {
                // Таблица 1: Начальные и максимальные значения Xn
                table1Data = [];
                for (let i = 1; i < 15; i++) {
                    table1Data.push({
                        id: i,
                        initial: i <= 14 ? (0.5 + Math.random() * 0.5).toFixed(2) : "0.00",
                        max: (0.8 + Math.random() * 0.2).toFixed(2)
                    });
                }
                
                // Таблица 2: Константные значения
                table2Data = [];
                constants.forEach((constant, index) => {
                    table2Data.push({
                        name: constant.name,
                        value: (0.1 + Math.random() * 0.9).toFixed(2)
                    });
                });
                
                // Таблица 3: Коэффициенты функций
                table3Data = [];
                for (let i = 1; i <= 150; i++) {
                    table3Data.push({
                        id: i,
                        a: (Math.random()).toFixed(3),
                        b: (Math.random()).toFixed(3),
                        c: (Math.random()).toFixed(3)
                    });
                }
                
                renderTables();
            }
            
            // Заполнение случайными значениями
            function fillRandomData() {
                // Таблица 1
                table1Data.forEach(item => {
                    item.initial = (Math.random()).toFixed(2);
                    item.max = (0.7 + Math.random() * 0.3).toFixed(2);
                });
                
                // Таблица 2
                table2Data.forEach(item => {
                    item.value = (Math.random()).toFixed(2);
                });
                
                // Таблица 3
                table3Data.forEach(item => {
                    item.a = (Math.random()).toFixed(3);
                    item.b = (Math.random()).toFixed(3);
                    item.c = (Math.random()).toFixed(3);
                });
                
                renderTables();
            }
            
            // Рендер таблиц
            function renderTables() {
                // Таблица 1
                const table1Body = document.getElementById('table1-body');
                table1Body.innerHTML = '';
                
                table1Data.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    const descIndex = Math.min(index, xnDescriptions.length - 1);
                    
                    row.innerHTML = `
                        <td>X<sub>${item.id}</sub></td>
                        <td>${xnDescriptions[descIndex]}</td>
                        <td><input type="number" step="0.01" min="0" max="1" class="xn-input" data-index="${index}" data-type="initial" value="${item.initial}"></td>
                        <td><input type="number" step="0.01" min="0" max="1" class="xn-input" data-index="${index}" data-type="max" value="${item.max}"></td>
                    `;
                    
                    table1Body.appendChild(row);
                });
                
                // Таблица 2
                const table2Body = document.getElementById('table2-body');
                table2Body.innerHTML = '';
                
                table2Data.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${item.name}</td>
                        <td>${constants[index].description}</td>
                        <td><input type="number" step="0.01" min="0" max="1" class="const-input" data-index="${index}" value="${item.value}"></td>
                    `;
                    
                    table2Body.appendChild(row);
                });
                
                // Таблица 3
                const table3Body = document.getElementById('table3-body');
                table3Body.innerHTML = '';
                
                // Показываем только первые 5 функций в таблице
                for (let i = 0; i < 150; i++) {
                    const item = table3Data[i];
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>f<sub>${item.id}</sub>(x)</td>
                        <td><input type="number" step="0.001" min="0" max="10" class="func-input" data-index="${i}" data-coeff="a" value="${item.a}"></td>
                        <td><input type="number" step="0.001" min="0" max="10" class="func-input" data-index="${i}" data-coeff="b" value="${item.b}"></td>
                        <td><input type="number" step="0.001" min="0" max="10" class="func-input" data-index="${i}" data-coeff="c" value="${item.c}"></td>
                    `;
                    
                    table3Body.appendChild(row);
                }
                
                // Полный список функций
                const functionList = document.getElementById('function-list');
                functionList.innerHTML = '';
                
                table3Data.forEach((item, index) => {
                    const funcItem = document.createElement('div');
                    funcItem.className = 'function-item';
                    funcItem.innerHTML = `f<sub>${item.id}</sub>(x) = ${item.a}·x² + ${item.b}·x + ${item.c}`;
                    functionList.appendChild(funcItem);
                });
                
                // Добавляем обработчики событий для инпутов
                addEventListeners();
            }
            
            // Добавление обработчиков событий
            function addEventListeners() {
                // Обработчики для таблицы 1
                document.querySelectorAll('.xn-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        const type = this.dataset.type;
                        table1Data[index][type] = this.value;
                        
                        // Обновляем список функций, если нужно
                        if (type === 'initial' && index === 0) {
                            updateFunctionList();
                        }
                    });
                });
                
                // Обработчики для таблицы 2
                document.querySelectorAll('.const-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        table2Data[index].value = this.value;
                    });
                });
                
                // Обработчики для таблицы 3
                document.querySelectorAll('.func-input').forEach(input => {
                    input.addEventListener('change', function() {
                        const index = parseInt(this.dataset.index);
                        const coeff = this.dataset.coeff;
                        table3Data[index][coeff] = this.value;
                        
                        // Обновляем список функций
                        updateFunctionList();
                    });
                });
            }
            
            // Обновление списка функций
            function updateFunctionList() {
                const functionList = document.getElementById('function-list');
                functionList.innerHTML = '';
                
                table3Data.forEach((item, index) => {
                    const funcItem = document.createElement('div');
                    funcItem.className = 'function-item';
                    funcItem.innerHTML = `f<sub>${item.id}</sub>(x) = ${item.a}·x² + ${item.b}·x + ${item.c}`;
                    functionList.appendChild(funcItem);
                });
            }

            function FValue(n,x){
                // Проверка входных данных
                if (x === undefined || x === null || isNaN(x)) {
                    console.warn(`Invalid x value for F${index}: ${x}`);
                    return 1; // нейтральное значение
                }
                
                // Ваша логика вычисления f(index, x)
                let result = parseFloat(table3Data[n].a * x * x + table3Data[n].b * x + table3Data[n].c)
                
                // Пример: сигмоидальная функция
                // result = 1 / (1 + Math.exp(-x));
                
                // Защита от проблем
                if (isNaN(result) || !isFinite(result)) {
                    console.warn(`NaN/Infinity in F${index}(${x}), returning 1`);
                    return 1;
                }
                
                // Ограничение диапазона
                if (result < 1e-10) result = 1e-10;
                if (result > 1e10) result = 1e10;
                
                return result;
            }
            
            // Расчет значений Xn в 5 временных точках
            function calculateXnValues() {
                const timePoints = 5;
                const xnCount = 14; // X1-X14
                
                // Получаем начальные значения Xn
                const initialValues = table1Data.slice(0, xnCount).map(item => parseFloat(item.initial));
                
                // Получаем коэффициенты для вычисления
                const const1 = parseFloat(table2Data[0].value); // ζ₁
                const const2 = parseFloat(table2Data[1].value);  // ζ₂
                const const3 = parseFloat(table2Data[2].value); // ζ₃
                const const4 = parseFloat(table2Data[3].value); // ζ₄
                const const5 = parseFloat(table2Data[4].value); // ζ₅
                
                // Массив для хранения значений Xn в 5 временных точках
                const xnOverTime = Array.from({length: timePoints}, () => []);
                
                // Инициализируем начальные значения (t=0)
                for (let i = 0; i < xnCount; i++) {
                    xnOverTime[0][i] = initialValues[i];
                }
                
                // Вычисляем значения для последующих временных точек
                for (let t = 1; t < timePoints; t++) {
                    for (let i = 0; i < xnCount; i++) {
                        // Простая модель изменения Xn во времени
                        // В реальной модели здесь использовались бы уравнения 2.9-2.21 из задания
                        
                        // Базовое изменение (затухание + случайные флуктуации)
                        let change = 0;
                        
                        // Влияние предыдущего значения
                        // change += const4 * xnOverTime[t-1][i];
                        
                        let calcVal = 1;
                        // Влияние других переменных (упрощенная модель)
                        switch (i){
                            case 0:
                                // Вычисляем новое значение X1
                                for (let j = 0; j < xnCount; j++){
                                    if (j===i) continue;
                                    
                                    calcVal *= FValue(j,xnOverTime[t-1][j]);
                                }

                                calcVal *= (const1 + const2 + const3 - const4 - const5)
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 1:
                                // Вычисляем новое значение X2
                                for (let j = 0; j < xnCount; j++){
                                    if (j===i) continue;

                                    calcVal *= FValue(14 + j,xnOverTime[t-1][j]);
                                }
                                calcVal *= (const1 + const2 + const3 + const4 - const5)
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 2:
                                // Вычисляем новое значение X3
                                for (let j = 0; j < xnCount; j++){
                                    if (j===i) continue;

                                    calcVal *= FValue(28 + j,xnOverTime[t-1][j]);
                                }

                                calcVal *= (const1 + const2 + const3 + const4 - const5) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 3:
                                // Вычисляем новое значение X4
                                for (let j = 0; j < xnCount; j++){
                                    //if (j===i) continue;
                                    if (j===4 || j===5 )continue

                                    calcVal *= FValue(42 + j,xnOverTime[t-1][j]);
                                }

                                calcVal *=  (const5) 
                                calcVal -= (const1 + const2 + const3 + const4 + FValue(46,xnOverTime[t-1][4])* FValue(47,xnOverTime[t-1][5])) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 4:
                                // Вычисляем новое значение X5
                                calcVal = (FValue(56,xnOverTime[t-1][3]) * FValue(57,xnOverTime[t-1][5]) * FValue(58,xnOverTime[t-1][8]) * FValue(59,xnOverTime[t-1][10]) * FValue(60,xnOverTime[t-1][12]))
                                calcVal *= (const1 + const2 + const4 +  const5)
                                calcVal -= const5
                                calcVal /= parseFloat(table1Data[i].max)
                                change += calcVal
                                break;
                            case 5:
                                // Вычисляем новое значение X6
                                for (let j = 0; j < xnCount; j++){
                                    if (j===i) continue;

                                    calcVal *= FValue(61 + j,xnOverTime[t-1][j]);
                                }

                                calcVal *=  (const1 + const2) 
                                calcVal -= (const5)
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 6:
                                // Вычисляем новое значение X7
                                calcVal = (FValue(75,xnOverTime[t-1][1]) * FValue(76,xnOverTime[t-1][3]) * FValue(77,xnOverTime[t-1][13]))
                                calcVal -= const5
                                calcVal /= parseFloat(table1Data[i].max)
                                change += calcVal
                                break;
                            case 7:
                                // Вычисляем новое значение X8
                                calcVal = (FValue(75,xnOverTime[t-1][0]) * FValue(76,xnOverTime[t-1][1]) * FValue(77,xnOverTime[t-1][2]) * FValue(78,xnOverTime[t-1][3]) * FValue(79,xnOverTime[t-1][5]) * FValue(80,xnOverTime[t-1][8]) * FValue(81,xnOverTime[t-1][9]))
                                calcVal *=  (const1 + const2 + const3) 
                                calcVal -= const1 + const2
                                calcVal /= parseFloat(table1Data[i].max)
                                change += calcVal
                                break;
                            case 8:
                                // Вычисляем новое значение X9
                                for (let j = 0; j < 7; j++){
                                    //if (j===i) continue;
                                    //if (j===4 || j===5 )continue

                                    calcVal *= FValue(82 + j,xnOverTime[t-1][j]);
                                }
                                calcVal *= (FValue(89,xnOverTime[t-1][9]) * FValue(90,xnOverTime[t-1][10]) * FValue(91,xnOverTime[t-1][11]) * FValue(92,xnOverTime[t-1][12]) * FValue(93,xnOverTime[t-1][13]) )   
                                calcVal *= (const4 + const5) 
                                calcVal -= (const1 + const2 + const3) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 9:
                                // Вычисляем новое значение X10
                                for (let j = 0; j < xnCount; j++){
                                    if (j===i) continue;
                                    if (j===12 || j===13 )continue

                                    calcVal *= FValue(94 + j,xnOverTime[t-1][j]);
                                }

                                calcVal *=  (const1 + const2) 
                                calcVal -= (const3 * FValue(106,xnOverTime[t-1][12])* FValue(107,xnOverTime[t-1][13])) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 10:
                                // Вычисляем новое значение X11
                                for (let j = 0; j < 9; j++){
                                    if (j===i) continue;
                                    if (j===12 || j===13 )continue

                                    calcVal *= FValue(108 + j,xnOverTime[t-1][j]);
                                }

                                calcVal -= ((const1 + const2 + const3 + const4 + const5) * FValue(117,xnOverTime[t-1][4])* FValue(118,xnOverTime[t-1][5]))

                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 11:
                                // Вычисляем новое значение X12
                                for (let j = 0; j < 12; j++){

                                    calcVal *= FValue(119 + j,xnOverTime[t-1][j]);
                                }

                                calcVal *=  (const1 + const4 + const5) * FValue(130,xnOverTime[t-1][12]) * FValue(131,xnOverTime[t-1][13]) 
                                calcVal -= (const3) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 12:
                                // Вычисляем новое значение X13
                                for (let j = 0; j < 12; j++){
                                    if (i === 8) continue
                                    calcVal *= FValue(132 + j,xnOverTime[t-1][j]);
                                }

                                calcVal -= (const1 + const2 + const3 + const4 + const5) * FValue(145,xnOverTime[t-1][8]) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                            case 13:
                                // Вычисляем новое значение X14
                                calcVal *= FValue(146 ,xnOverTime[t-1][4]) * FValue(147 ,xnOverTime[t-1][6]) * FValue(148,xnOverTime[t-1][10]) * FValue(149 ,xnOverTime[t-1][12])

                                calcVal -= (const1 + const2 + const3 + const4 + const5) 
                                calcVal /= parseFloat(table1Data[i].max)

                                change += calcVal
                                break;
                        }

                        // Вычисляем новое значение Xn
                        let newValue = xnOverTime[t-1][i] + change * 0.05;

                        // Ограничиваем максимальным значением
                        const maxValue = parseFloat(table1Data[i].max);
                        newValue = Math.min(maxValue, newValue);
                        

                        // Ограничиваем минимальным значением 0
                        newValue = Math.max(0, newValue);
                        
                        xnOverTime[t][i] = parseFloat(newValue.toFixed(3));
                    }
                }
                
                return xnOverTime;
            }
            
            // Создание лепестковых графиков
            function createRadarCharts(xnOverTime) {
                const chartsContainer = document.getElementById('charts-container');
                chartsContainer.innerHTML = '';
                
                const timeLabels = ['t=0 (начало)', 't=1', 't=2', 't=3', 't=4'];
                const xnLabels = Array.from({length: 14}, (_, i) => `X${i+1}`);
                
                // Цвета для графиков
                const chartColors = [
                    'rgba(26, 75, 140, 0.7)',
                    'rgba(65, 105, 225, 0.7)',
                    'rgba(70, 130, 180, 0.7)',
                    'rgba(100, 149, 237, 0.7)',
                    'rgba(30, 144, 255, 0.7)'
                ];
                
                // Создаем 5 графиков для каждого момента времени
                for (let t = 0; t < 5; t++) {
                    const chartWrapper = document.createElement('div');
                    chartWrapper.className = 'chart-wrapper';
                    
                    const chartTitle = document.createElement('div');
                    chartTitle.className = 'chart-title';
                    chartTitle.textContent = timeLabels[t];
                    
                    // Добавляем информацию о максимальных значениях
                    const maxInfo = document.createElement('div');
                    maxInfo.className = 'chart-subtitle';
                    maxInfo.innerHTML = '<small>Макс. значения: X₁=' + table1Data[0].max + 
                                        ', X₈=' + table1Data[7].max + 
                                        ', X₁₄=' + table1Data[13].max + '</small>';
                    
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart-${t}`;
                    
                    chartWrapper.appendChild(chartTitle);
                    chartWrapper.appendChild(maxInfo);
                    chartWrapper.appendChild(canvas);
                    chartsContainer.appendChild(chartWrapper);
                    
                    // Получаем максимальные значения для каждой характеристики
                    const maxValues = [];
                    for (let i = 0; i < 14; i++) {
                        maxValues.push(parseFloat(table1Data[i].max));
                    }
                    
                    // Находим максимальное из максимальных значений для масштаба графика
                    const overallMax = Math.max(...maxValues);
                    
                    // Создаем график
                    const ctx = canvas.getContext('2d');
                    new Chart(ctx, {
                        type: 'radar',
                        data: {
                            labels: xnLabels,
                            datasets: [
                                {
                                    label: `Текущие значения X₁-X₁₄`,
                                    data: xnOverTime[t],
                                    backgroundColor: chartColors[t],
                                    borderColor: chartColors[t].replace('0.7', '1'),
                                    borderWidth: 2,
                                    pointBackgroundColor: chartColors[t].replace('0.7', '1'),
                                    pointRadius: 4
                                },
                                {
                                    label: 'Максимальные значения',
                                    data: maxValues,
                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                                    borderColor: 'rgba(255, 99, 132, 0.8)',
                                    borderWidth: 1,
                                    borderDash: [5, 5],
                                    pointBackgroundColor: 'rgba(255, 99, 132, 0.8)',
                                    pointRadius: 2,
                                    fill: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            scales: {
                                r: {
                                    beginAtZero: true,
                                    max: overallMax,
                                    ticks: {
                                        stepSize: overallMax / 5,
                                        callback: function(value) {
                                            return value.toFixed(2);
                                        }
                                    },
                                    pointLabels: {
                                        font: {
                                            size: 11
                                        },
                                        callback: function(label, index) {
                                            // Добавляем максимальное значение к названию характеристики
                                            return label + ' (max: ' + maxValues[index].toFixed(2) + ')';
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const datasetLabel = context.dataset.label;
                                            const index = context.dataIndex;
                                            const value = context.raw;
                                            const maxVal = maxValues[index];
                                            const percent = ((value / maxVal) * 100).toFixed(1);
                                            
                                            if (context.datasetIndex === 0) {
                                                return `${datasetLabel}: ${value.toFixed(3)} (${percent}% от макс.)`;
                                            } else {
                                                return `${datasetLabel}: ${value.toFixed(3)}`;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
            
            // Обработчики кнопок
            document.getElementById('calculate-btn').addEventListener('click', function() {
                const xnOverTime = calculateXnValues();
                createRadarCharts(xnOverTime);
                
                // Прокрутка к графикам
                document.querySelector('.section:nth-last-child(2)').scrollIntoView({
                    behavior: 'smooth'
                });
            });
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                initDefaultData();
            });
            
            document.getElementById('random-btn').addEventListener('click', function() {
                fillRandomData();
            });
            
            // Инициализация при загрузке
            initDefaultData();
            
            // Автоматический расчет при загрузке
            setTimeout(() => {
                const xnOverTime = calculateXnValues();
                createRadarCharts(xnOverTime);
            }, 500);
        });
    </script>
</body>
</html>